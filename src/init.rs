use crate::config::{AiApp, Mode, ProjectConfig};
use crate::error::Result;
use crossterm::{
    cursor,
    event::{self, Event, KeyCode, KeyModifiers},
    execute,
    style::Stylize,
    terminal::{self, ClearType},
};
use std::fs;
use std::io::{self, Write};

#[derive(Debug, Clone)]
struct AiService {
    name: &'static str,
    normal_command: &'static str,
    yolo_command: &'static str,
}

impl AiService {
    const SERVICES: &'static [AiService] = &[
        AiService {
            name: "claude",
            normal_command: "claude",
            yolo_command: "claude --dangerously-skip-permissions",
        },
        AiService {
            name: "gemini",
            normal_command: "gemini",
            yolo_command: "gemini --yolo",
        },
        AiService {
            name: "codex",
            normal_command: "codex",
            yolo_command: "codex --ask-for-approval never",
        },
        AiService {
            name: "amp",
            normal_command: "amp",
            yolo_command: "amp --dangerously-allow-all",
        },
        AiService {
            name: "opencode",
            normal_command: "opencode",
            yolo_command: "opencode",
        },
        AiService {
            name: "cursor-agent",
            normal_command: "cursor-agent",
            yolo_command: "cursor-agent --force",
        },
    ];
}

pub fn run_init() -> Result<()> {
    println!("Welcome to Multi-AI CLI configuration!");
    println!("This will help you create a multi-ai-config.jsonc file.");
    println!(); // Add empty line before interactive selection
    
    // First, select which AI services to include
    let selected_services = select_ai_services()?;
    
    if selected_services.is_empty() {
        println!("No AI services selected. Exiting without creating config file.");
        return Ok(());
    }
    
    // Then for each selected service, choose normal or yolo mode
    let mut selected_apps = Vec::new();
    
    for service in selected_services {
        println!("\nConfiguring {}:", service.name);
        let use_yolo = select_mode(service.name)?;
        
        let command = if use_yolo {
            service.yolo_command
        } else {
            service.normal_command
        };
        
        selected_apps.push(AiApp {
            name: service.name.to_string(),
            command: command.to_string(),
        });
        
        println!("  ✓ {} will use: {}", service.name, command);
    }
    
    // Mode selection
    println!("\nSelect terminal mode to use by default:");
    let terminal_mode = select_terminal_mode()?;

    let config = ProjectConfig { 
        ai_apps: selected_apps,
        terminals_per_column: 2,  // Default value
        mode: terminal_mode.clone(),
    };
    
    let json_content = format!(
        r#"{{
  // Multi-AI CLI configuration
  // Generated by: mai init
  "terminals_per_column": {},  // Number of terminal panes per column (first is AI command, rest are shells)
  "mode": "{}",               // Required: iterm2 | tmux-single-window | tmux-multi-window
  "ai_apps": [{}
  ]
}}"#,
        config.terminals_per_column,
        match terminal_mode { Mode::Iterm2 => "iterm2", Mode::TmuxSingleWindow => "tmux-single-window", Mode::TmuxMultiWindow => "tmux-multi-window" },
        config.ai_apps.iter()
            .map(|app| format!(
                r#"
    {{
      "name": "{}",
      "command": "{}"
    }}"#,
                app.name, app.command
            ))
            .collect::<Vec<_>>()
            .join(",")
    );
    
    let config_path = "multi-ai-config.jsonc";
    
    if fs::metadata(config_path).is_ok() && !ask_yes_no(&format!("\n{} already exists. Overwrite?", config_path))? {
        println!("Configuration not saved.");
        return Ok(());
    }
    
    fs::write(config_path, json_content)?;
    println!("\n✓ Configuration saved to {}", config_path);
    println!("\nYou can now run:");
    println!("  mai add <branch-prefix>              # Uses mode from config");
    println!("  mai add <branch-prefix> --tmux       # Override to tmux-multi-window regardless of config");
    
    Ok(())
}

fn select_ai_services() -> Result<Vec<AiService>> {
    let mut stdout = io::stdout();
    let mut selected = vec![false; AiService::SERVICES.len()];
    let mut cursor_pos = 0;
    
    // Save cursor position and enable raw mode
    execute!(stdout, cursor::SavePosition)?;
    terminal::enable_raw_mode()?;
    
    let result = (|| -> Result<Vec<AiService>> {
        loop {
            // Restore cursor position and clear from there
            execute!(
                stdout,
                cursor::RestorePosition,
                terminal::Clear(ClearType::FromCursorDown)
            )?;
            
            // Use print! and write! instead of println! to avoid extra newlines in raw mode
            writeln!(stdout, "Select AI services to include:")?;
            writeln!(stdout, "(Use ↑/↓ to navigate, Space to toggle, Enter to continue, Ctrl+C to exit)\r")?;
            writeln!(stdout, "\r")?;
            
            for (i, service) in AiService::SERVICES.iter().enumerate() {
                let checkbox = if selected[i] { "[✓]" } else { "[ ]" };
                let line = format!(" {} {}", checkbox, service.name);
                
                if i == cursor_pos {
                    writeln!(stdout, "{}\r", line.on_dark_grey().white())?;
                } else {
                    writeln!(stdout, "{}\r", line)?;
                }
            }
            
            stdout.flush()?;
            
            // Handle input
            if let Event::Key(key) = event::read()? {
                match key.code {
                    KeyCode::Up => {
                        cursor_pos = cursor_pos.saturating_sub(1);
                    }
                    KeyCode::Down => {
                        if cursor_pos < AiService::SERVICES.len() - 1 {
                            cursor_pos += 1;
                        }
                    }
                    KeyCode::Char(' ') => {
                        selected[cursor_pos] = !selected[cursor_pos];
                    }
                    KeyCode::Enter => {
                        break;
                    }
                    KeyCode::Char('c') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                        // Handle Ctrl+C
                        terminal::disable_raw_mode()?;
                        execute!(stdout, cursor::RestorePosition, terminal::Clear(ClearType::FromCursorDown))?;
                        println!("\r\nCancelled.");
                        std::process::exit(0);
                    }
                    KeyCode::Esc | KeyCode::Char('q') => {
                        terminal::disable_raw_mode()?;
                        execute!(stdout, cursor::RestorePosition, terminal::Clear(ClearType::FromCursorDown))?;
                        println!("\r\nCancelled.");
                        std::process::exit(0);
                    }
                    _ => {}
                }
            }
        }
        
        let selected_services: Vec<AiService> = AiService::SERVICES
            .iter()
            .enumerate()
            .filter_map(|(i, service)| {
                if selected[i] {
                    Some(service.clone())
                } else {
                    None
                }
            })
            .collect();
        
        Ok(selected_services)
    })();
    
    // Always disable raw mode and restore cursor
    terminal::disable_raw_mode()?;
    execute!(stdout, cursor::RestorePosition, terminal::Clear(ClearType::FromCursorDown))?;
    
    match result {
        Ok(services) => {
            if !services.is_empty() {
                println!("Selected services: {}\n", 
                    services.iter()
                        .map(|s| s.name)
                        .collect::<Vec<_>>()
                        .join(", "));
            }
            Ok(services)
        }
        Err(e) => Err(e)
    }
}

fn select_mode(service_name: &str) -> Result<bool> {
    let mut stdout = io::stdout();
    let mut use_yolo = true; // Default to yolo mode
    
    // Save cursor position and enable raw mode
    execute!(stdout, cursor::SavePosition)?;
    terminal::enable_raw_mode()?;
    
    let result = (|| -> Result<bool> {
        loop {
            // Restore cursor position and clear from there
            execute!(
                stdout,
                cursor::RestorePosition,
                terminal::Clear(ClearType::FromCursorDown)
            )?;
            
            writeln!(stdout, "Select mode for {}:", service_name)?;
            writeln!(stdout, "(Use ↑/↓ to select, Enter to confirm, Ctrl+C to exit)\r")?;
            writeln!(stdout, "\r")?;
            
            let normal_line = " [ ] Normal mode (will ask for permissions)";
            let yolo_line = " [ ] YOLO mode (skip permission prompts)";
            
            if use_yolo {
                writeln!(stdout, "{}\r", normal_line)?;
                writeln!(stdout, "{}\r", yolo_line.replace("[ ]", "[✓]").on_dark_grey().white())?;
            } else {
                writeln!(stdout, "{}\r", normal_line.replace("[ ]", "[✓]").on_dark_grey().white())?;
                writeln!(stdout, "{}\r", yolo_line)?;
            }
            
            stdout.flush()?;
            
            if let Event::Key(key) = event::read()? {
                match key.code {
                    KeyCode::Up | KeyCode::Down => {
                        use_yolo = !use_yolo;
                    }
                    KeyCode::Enter => {
                        break;
                    }
                    KeyCode::Char('c') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                        // Handle Ctrl+C
                        terminal::disable_raw_mode()?;
                        execute!(stdout, cursor::RestorePosition, terminal::Clear(ClearType::FromCursorDown))?;
                        println!("\r\nCancelled.");
                        std::process::exit(0);
                    }
                    KeyCode::Esc | KeyCode::Char('q') => {
                        terminal::disable_raw_mode()?;
                        execute!(stdout, cursor::RestorePosition, terminal::Clear(ClearType::FromCursorDown))?;
                        println!("\r\nCancelled.");
                        std::process::exit(0);
                    }
                    _ => {}
                }
            }
        }
        
        Ok(use_yolo)
    })();
    
    // Always disable raw mode and restore cursor
    terminal::disable_raw_mode()?;
    execute!(stdout, cursor::RestorePosition, terminal::Clear(ClearType::FromCursorDown))?;
    
    result
}

fn select_terminal_mode() -> Result<Mode> {
    let mut stdout = io::stdout();
    // Default selection depends on OS: iTerm2 on macOS, tmux-multi-window otherwise
    #[cfg(target_os = "macos")]
    let mut selection: i32 = 0; // 0: iterm2, 1: tmux-multi, 2: tmux-single
    #[cfg(not(target_os = "macos"))]
    let mut selection: i32 = 0; // 0: tmux-multi, 1: tmux-single

    execute!(stdout, cursor::SavePosition)?;
    terminal::enable_raw_mode()?;

    let result = (|| -> Result<Mode> {
        loop {
            execute!(
                stdout,
                cursor::RestorePosition,
                terminal::Clear(ClearType::FromCursorDown)
            )?;

            writeln!(stdout, "Select mode:")?;
            writeln!(stdout, "(Use ↑/↓ to select, Enter to confirm, Ctrl+C to exit)\r")?;
            writeln!(stdout, "\r")?;

            #[cfg(target_os = "macos")]
            {
                let options = [
                    " [ ] iTerm2 (macOS only)",
                    " [ ] tmux multi-window",
                    " [ ] tmux single-window",
                ];
                for (i, line) in options.iter().enumerate() {
                    if selection == i as i32 {
                        writeln!(stdout, "{}\r", line.replace("[ ]", "[✓]").on_dark_grey().white())?;
                    } else {
                        writeln!(stdout, "{}\r", line)?;
                    }
                }
            }

            #[cfg(not(target_os = "macos"))]
            {
                let options = [
                    " [ ] tmux multi-window",
                    " [ ] tmux single-window",
                ];
                for (i, line) in options.iter().enumerate() {
                    if selection == i as i32 {
                        writeln!(stdout, "{}\r", line.replace("[ ]", "[✓]").on_dark_grey().white())?;
                    } else {
                        writeln!(stdout, "{}\r", line)?;
                    }
                }
            }

            stdout.flush()?;

            if let Event::Key(key) = event::read()? {
                match key.code {
                    KeyCode::Up | KeyCode::Down => {
                        #[cfg(target_os = "macos")]
                        {
                            let max = 2;
                            if matches!(key.code, KeyCode::Up) {
                                selection = (selection - 1).rem_euclid(max + 1);
                            } else {
                                selection = (selection + 1).rem_euclid(max + 1);
                            }
                        }
                        #[cfg(not(target_os = "macos"))]
                        {
                            let max = 1;
                            if matches!(key.code, KeyCode::Up) {
                                selection = (selection - 1).rem_euclid(max + 1);
                            } else {
                                selection = (selection + 1).rem_euclid(max + 1);
                            }
                        }
                    }
                    KeyCode::Enter => {
                        break;
                    }
                    KeyCode::Char('c') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                        // Handle Ctrl+C
                        terminal::disable_raw_mode()?;
                        execute!(stdout, cursor::RestorePosition, terminal::Clear(ClearType::FromCursorDown))?;
                        println!("\r\nCancelled.");
                        std::process::exit(0);
                    }
                    KeyCode::Esc | KeyCode::Char('q') => {
                        terminal::disable_raw_mode()?;
                        execute!(stdout, cursor::RestorePosition, terminal::Clear(ClearType::FromCursorDown))?;
                        println!("\r\nCancelled.");
                        std::process::exit(0);
                    }
                    _ => {}
                }
            }
        }

        #[cfg(target_os = "macos")]
        let mode = match selection {
            0 => Mode::Iterm2,
            1 => Mode::TmuxMultiWindow,
            _ => Mode::TmuxSingleWindow,
        };

        #[cfg(not(target_os = "macos"))]
        let mode = match selection {
            0 => Mode::TmuxMultiWindow,
            _ => Mode::TmuxSingleWindow,
        };

        Ok(mode)
    })();

    terminal::disable_raw_mode()?;
    execute!(stdout, cursor::RestorePosition, terminal::Clear(ClearType::FromCursorDown))?;

    result
}

// removed select_tmux_layout in favor of select_terminal_mode

fn ask_yes_no(question: &str) -> Result<bool> {
    loop {
        print!("{} [y/n]: ", question);
        io::stdout().flush()?;
        
        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        
        match input.trim().to_lowercase().as_str() {
            "y" | "yes" => return Ok(true),
            "n" | "no" => return Ok(false),
            _ => println!("Please enter 'y' or 'n'"),
        }
    }
}
