use crate::config::{AiApp, Mode, ProjectConfig};
use crate::error::Result;
use crossterm::{
    cursor,
    event::{self, Event, KeyCode, KeyModifiers},
    execute,
    style::Stylize,
    terminal::{self, ClearType},
};
use std::fs;
use std::io::{self, Write};

#[derive(Debug, Clone)]
struct AiService {
    name: &'static str,
    normal_command: &'static str,
    yolo_command: &'static str,
}

impl AiService {
    const SERVICES: &'static [AiService] = &[
        AiService {
            name: "claude",
            normal_command: "claude",
            yolo_command: "claude --dangerously-skip-permissions",
        },
        AiService {
            name: "gemini",
            normal_command: "gemini",
            yolo_command: "gemini --yolo",
        },
        AiService {
            name: "codex",
            normal_command: "codex",
            yolo_command: "codex --ask-for-approval never",
        },
        AiService {
            name: "amp",
            normal_command: "amp",
            yolo_command: "amp --dangerously-allow-all",
        },
        AiService {
            name: "opencode",
            normal_command: "opencode",
            yolo_command: "opencode",
        },
        AiService {
            name: "cursor-agent",
            normal_command: "cursor-agent",
            yolo_command: "cursor-agent --force",
        },
    ];
}

pub fn run_init() -> Result<()> {
    println!("Welcome to Multi-AI CLI configuration!");
    println!("This will help you create a multi-ai-config.jsonc file.");
    println!(); // Add empty line before interactive selection

    // First, select which AI services to include
    let selected_services = select_ai_services()?;

    if selected_services.is_empty() {
        println!("No AI services selected. Exiting without creating config file.");
        return Ok(());
    }

    // Then for each selected service, choose normal or yolo mode
    let mut selected_apps = Vec::new();

    for service in selected_services {
        println!("\nConfiguring {}:", service.name);
        let use_yolo = select_mode(service.name)?;

        let command = if use_yolo {
            service.yolo_command
        } else {
            service.normal_command
        };

        selected_apps.push(AiApp {
            name: service.name.to_string(),
            command: command.to_string(),
        });

        println!("  ✓ {} will use: {}", service.name, command);
    }

    // Mode selection
    println!("\nSelect terminal mode to use by default:");
    let terminal_mode = select_terminal_mode()?;

    let config = ProjectConfig {
        ai_apps: selected_apps,
        terminals_per_column: 2, // Default value
        mode: Some(terminal_mode.clone()),
    };

    let json_content = format!(
        r#"{{
  // Multi-AI CLI configuration
  // Generated by: mai init
  "terminals_per_column": {},  // Number of terminal panes per column (first is AI command, rest are shells)
  "mode": "{}",               // Required: iterm2 | tmux-single-window | tmux-multi-window
  "ai_apps": [{}
  ]
}}"#,
        config.terminals_per_column,
        match terminal_mode {
            Mode::Iterm2 => "iterm2",
            Mode::TmuxSingleWindow => "tmux-single-window",
            Mode::TmuxMultiWindow => "tmux-multi-window",
        },
        config
            .ai_apps
            .iter()
            .map(|app| format!(
                r#"
    {{
      "name": "{}",
      "command": "{}"
    }}"#,
                app.name, app.command
            ))
            .collect::<Vec<_>>()
            .join(",")
    );

    let config_path = "multi-ai-config.jsonc";

    if fs::metadata(config_path).is_ok()
        && !ask_yes_no(&format!("\n{} already exists. Overwrite?", config_path))?
    {
        println!("Configuration not saved.");
        return Ok(());
    }

    fs::write(config_path, json_content)?;
    println!("\n✓ Configuration saved to {}", config_path);
    println!("\nYou can now run:");
    println!("  mai add <branch-prefix>              # Uses mode from config");
    println!("  mai add <branch-prefix> --mode tmux-single-window  # Override for a single run");
    println!("  mai add <branch-prefix> --tmux       # Legacy alias for tmux-multi-window");

    Ok(())
}

fn select_ai_services() -> Result<Vec<AiService>> {
    let mut stdout = io::stdout();
    let mut selected = vec![false; AiService::SERVICES.len()];
    let mut cursor_pos = 0;

    // Save cursor position and enable raw mode
    execute!(stdout, cursor::SavePosition)?;
    terminal::enable_raw_mode()?;

    let result = (|| -> Result<Vec<AiService>> {
        loop {
            // Restore cursor position and clear from there
            execute!(
                stdout,
                cursor::RestorePosition,
                terminal::Clear(ClearType::FromCursorDown)
            )?;

            // Use print! and write! instead of println! to avoid extra newlines in raw mode
            writeln!(stdout, "Select AI services to include:")?;
            writeln!(
                stdout,
                "(Use ↑/↓ to navigate, Space to toggle, Enter to continue, Ctrl+C to exit)\r"
            )?;
            writeln!(stdout, "\r")?;

            for (i, service) in AiService::SERVICES.iter().enumerate() {
                let checkbox = if selected[i] { "[✓]" } else { "[ ]" };
                let line = format!(" {} {}", checkbox, service.name);

                if i == cursor_pos {
                    writeln!(stdout, "{}\r", line.on_dark_grey().white())?;
                } else {
                    writeln!(stdout, "{}\r", line)?;
                }
            }

            stdout.flush()?;

            // Handle input
            if let Event::Key(key) = event::read()? {
                match key.code {
                    KeyCode::Up => {
                        cursor_pos = cursor_pos.saturating_sub(1);
                    }
                    KeyCode::Down => {
                        if cursor_pos < AiService::SERVICES.len() - 1 {
                            cursor_pos += 1;
                        }
                    }
                    KeyCode::Char(' ') => {
                        selected[cursor_pos] = !selected[cursor_pos];
                    }
                    KeyCode::Enter => {
                        break;
                    }
                    KeyCode::Char('c') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                        // Handle Ctrl+C
                        terminal::disable_raw_mode()?;
                        execute!(
                            stdout,
                            cursor::RestorePosition,
                            terminal::Clear(ClearType::FromCursorDown)
                        )?;
                        println!("\r\nCancelled.");
                        std::process::exit(0);
                    }
                    KeyCode::Esc | KeyCode::Char('q') => {
                        terminal::disable_raw_mode()?;
                        execute!(
                            stdout,
                            cursor::RestorePosition,
                            terminal::Clear(ClearType::FromCursorDown)
                        )?;
                        println!("\r\nCancelled.");
                        std::process::exit(0);
                    }
                    _ => {}
                }
            }
        }

        let selected_services: Vec<AiService> = AiService::SERVICES
            .iter()
            .enumerate()
            .filter_map(|(i, service)| {
                if selected[i] {
                    Some(service.clone())
                } else {
                    None
                }
            })
            .collect();

        Ok(selected_services)
    })();

    // Always disable raw mode and restore cursor
    terminal::disable_raw_mode()?;
    execute!(
        stdout,
        cursor::RestorePosition,
        terminal::Clear(ClearType::FromCursorDown)
    )?;

    match result {
        Ok(services) => {
            if !services.is_empty() {
                println!(
                    "Selected services: {}\n",
                    services
                        .iter()
                        .map(|s| s.name)
                        .collect::<Vec<_>>()
                        .join(", ")
                );
            }
            Ok(services)
        }
        Err(e) => Err(e),
    }
}

fn select_mode(service_name: &str) -> Result<bool> {
    let mut stdout = io::stdout();
    let mut use_yolo = true; // Default to yolo mode

    // Save cursor position and enable raw mode
    execute!(stdout, cursor::SavePosition)?;
    terminal::enable_raw_mode()?;

    let result = (|| -> Result<bool> {
        loop {
            // Restore cursor position and clear from there
            execute!(
                stdout,
                cursor::RestorePosition,
                terminal::Clear(ClearType::FromCursorDown)
            )?;

            writeln!(stdout, "Select mode for {}:", service_name)?;
            writeln!(
                stdout,
                "(Use ↑/↓ to select, Enter to confirm, Ctrl+C to exit)\r"
            )?;
            writeln!(stdout, "\r")?;

            let normal_line = " [ ] Normal mode (will ask for permissions)";
            let yolo_line = " [ ] YOLO mode (skip permission prompts)";

            if use_yolo {
                writeln!(stdout, "{}\r", normal_line)?;
                writeln!(
                    stdout,
                    "{}\r",
                    yolo_line.replace("[ ]", "[✓]").on_dark_grey().white()
                )?;
            } else {
                writeln!(
                    stdout,
                    "{}\r",
                    normal_line.replace("[ ]", "[✓]").on_dark_grey().white()
                )?;
                writeln!(stdout, "{}\r", yolo_line)?;
            }

            stdout.flush()?;

            if let Event::Key(key) = event::read()? {
                match key.code {
                    KeyCode::Up | KeyCode::Down => {
                        use_yolo = !use_yolo;
                    }
                    KeyCode::Enter => {
                        break;
                    }
                    KeyCode::Char('c') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                        // Handle Ctrl+C
                        terminal::disable_raw_mode()?;
                        execute!(
                            stdout,
                            cursor::RestorePosition,
                            terminal::Clear(ClearType::FromCursorDown)
                        )?;
                        println!("\r\nCancelled.");
                        std::process::exit(0);
                    }
                    KeyCode::Esc | KeyCode::Char('q') => {
                        terminal::disable_raw_mode()?;
                        execute!(
                            stdout,
                            cursor::RestorePosition,
                            terminal::Clear(ClearType::FromCursorDown)
                        )?;
                        println!("\r\nCancelled.");
                        std::process::exit(0);
                    }
                    _ => {}
                }
            }
        }

        Ok(use_yolo)
    })();

    // Always disable raw mode and restore cursor
    terminal::disable_raw_mode()?;
    execute!(
        stdout,
        cursor::RestorePosition,
        terminal::Clear(ClearType::FromCursorDown)
    )?;

    result
}

fn render_options(stdout: &mut io::Stdout, options: &[&str], selected_index: i32) -> Result<()> {
    for (i, line) in options.iter().enumerate() {
        if selected_index == i as i32 {
            writeln!(
                stdout,
                "{}\r",
                line.replace("[ ]", "[✓]").on_dark_grey().white()
            )?;
        } else {
            writeln!(stdout, "{}\r", line)?;
        }
    }
    Ok(())
}

fn select_terminal_mode() -> Result<Mode> {
    let mut stdout = io::stdout();
    // Default selection matches the platform default mode
    let default_mode = Mode::default_for_platform();
    #[cfg(target_os = "macos")]
    let mut selection: i32 = match default_mode {
        Mode::Iterm2 => 0,
        Mode::TmuxMultiWindow => 1,
        Mode::TmuxSingleWindow => 2,
    };
    #[cfg(not(target_os = "macos"))]
    let mut selection: i32 = match default_mode {
        Mode::TmuxMultiWindow => 0,
        Mode::TmuxSingleWindow => 1,
        Mode::Iterm2 => 0, // Shouldn't happen on non-macOS, but handle it
    };

    execute!(stdout, cursor::SavePosition)?;
    terminal::enable_raw_mode()?;

    let result = (|| -> Result<Mode> {
        loop {
            execute!(
                stdout,
                cursor::RestorePosition,
                terminal::Clear(ClearType::FromCursorDown)
            )?;

            writeln!(stdout, "Select mode:")?;
            writeln!(
                stdout,
                "(Use ↑/↓ to select, Enter to confirm, Ctrl+C to exit)\r"
            )?;
            writeln!(stdout, "\r")?;

            #[cfg(target_os = "macos")]
            {
                let options = [
                    " [ ] iTerm2 (macOS only)",
                    " [ ] tmux multi-window",
                    " [ ] tmux single-window",
                ];
                render_options(&mut stdout, &options, selection)?;
            }

            #[cfg(not(target_os = "macos"))]
            {
                let options = [" [ ] tmux multi-window", " [ ] tmux single-window"];
                render_options(&mut stdout, &options, selection)?;
            }

            stdout.flush()?;

            if let Event::Key(key) = event::read()? {
                match key.code {
                    KeyCode::Up | KeyCode::Down => {
                        #[cfg(target_os = "macos")]
                        {
                            let max = 2;
                            if matches!(key.code, KeyCode::Up) {
                                selection = (selection - 1).rem_euclid(max + 1);
                            } else {
                                selection = (selection + 1).rem_euclid(max + 1);
                            }
                        }
                        #[cfg(not(target_os = "macos"))]
                        {
                            let max = 1;
                            if matches!(key.code, KeyCode::Up) {
                                selection = (selection - 1).rem_euclid(max + 1);
                            } else {
                                selection = (selection + 1).rem_euclid(max + 1);
                            }
                        }
                    }
                    KeyCode::Enter => {
                        break;
                    }
                    KeyCode::Char('c') if key.modifiers.contains(KeyModifiers::CONTROL) => {
                        // Handle Ctrl+C
                        terminal::disable_raw_mode()?;
                        execute!(
                            stdout,
                            cursor::RestorePosition,
                            terminal::Clear(ClearType::FromCursorDown)
                        )?;
                        println!("\r\nCancelled.");
                        std::process::exit(0);
                    }
                    KeyCode::Esc | KeyCode::Char('q') => {
                        terminal::disable_raw_mode()?;
                        execute!(
                            stdout,
                            cursor::RestorePosition,
                            terminal::Clear(ClearType::FromCursorDown)
                        )?;
                        println!("\r\nCancelled.");
                        std::process::exit(0);
                    }
                    _ => {}
                }
            }
        }

        #[cfg(target_os = "macos")]
        let mode = match selection {
            0 => Mode::Iterm2,
            1 => Mode::TmuxMultiWindow,
            _ => Mode::TmuxSingleWindow,
        };

        #[cfg(not(target_os = "macos"))]
        let mode = match selection {
            0 => Mode::TmuxMultiWindow,
            _ => Mode::TmuxSingleWindow,
        };

        Ok(mode)
    })();

    terminal::disable_raw_mode()?;
    execute!(
        stdout,
        cursor::RestorePosition,
        terminal::Clear(ClearType::FromCursorDown)
    )?;

    result
}

// removed select_tmux_layout in favor of select_terminal_mode

fn ask_yes_no(question: &str) -> Result<bool> {
    loop {
        print!("{} [y/n]: ", question);
        io::stdout().flush()?;

        let mut input = String::new();
        io::stdin().read_line(&mut input)?;

        match input.trim().to_lowercase().as_str() {
            "y" | "yes" => return Ok(true),
            "n" | "no" => return Ok(false),
            _ => println!("Please enter 'y' or 'n'"),
        }
    }
}
